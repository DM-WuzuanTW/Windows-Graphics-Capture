# ⚠️ Windows API 技術限制說明

## 當前狀態
應用程式已正常運行，但僅能排除 **本應用程式自己的視窗**（例如主視窗）。

## 為什麼無法排除其他程式的視窗？

Windows API 函數 `SetWindowDisplayAffinity` 有一個 **安全限制**：

```
只能由創建該視窗的進程呼叫
```

這是 Windows 的 **UIPI (User Interface Privilege Isolation)** 機制，用於防止惡意程式干擾其他應用程式。

### 具體表現
| 目標視窗 | 所屬進程 | 嘗試排除的進程 | 結果 |
|----------|----------|----------------|------|
| `cmd.exe` 視窗 | `cmd.exe` | 本 Electron 應用程式 | ❌ Error 5 (Access Denied) |
| `chrome.exe` 視窗 | `chrome.exe` | 本 Electron 應用程式 | ❌ Error 5 (Access Denied) |
| 本工具的主視窗 | 本 Electron 應用程式 | 本 Electron 應用程式 | ✅ 成功 |

## DLL 注入方案的挑戰

我們曾嘗試實現 DLL 注入來繞過此限制，但遇到以下技術困難：

1. **指針類型轉換**：koffi 返回的指針需要複雜的類型轉換才能進行運算
2. **跨進程參數傳遞**：需要在遠端進程中分配記憶體並正確傳遞函數參數
3. **函數地址計算**：需要精確計算遠端進程中 DLL 函數的地址偏移
4. **防毒軟體誤報**：DLL 注入技術可能被防毒軟體攔截

### DLL 已編譯但未使用
雖然 `dll/window_hider.dll` 已成功編譯，但 `dllInjector.js` 中的注入邏輯已暫時停用，以避免上述複雜性和錯誤。

## 建議使用方式

1. **僅排除本工具的視窗**  
   這是目前可靠且安全的唯一方式。

2. **使用其他螢幕錄製工具**  
   某些專業錄製軟體（如 OBS Studio）提供視窗過濾功能，可能有不同的實現方式。

3. **等待未來的完整 DLL 注入實現**  
   如果您具備 C++/Windows API 經驗，可以協助完善 DLL 注入功能（需要深入的跨進程程式設計知識）。

## 技術細節（給開發者）

要實現真正的跨進程視窗排除，需要：

1. **LoadLibrary**：在目標進程中載入 `window_hider.dll`
2. **GetProcAddress**：取得 `SetWindowAffinity` 函數地址
3. **CreateRemoteThread**：在目標進程中執行該函數
4. **參數傳遞**：正確分配遠端記憶體並寫入參數（hwnd, exclude）
5. **錯誤處理**：處理載入失敗、權限不足、目標進程崩潰等情況

這需要 **大量的低階 Windows API 知識** 和 **仔細的記憶體管理**。

## 結論

**應用程式功能正常，僅受限於 Windows API 的安全機制。**

如果您只需要排除本工具自己的視窗，現在的實現已經完全足夠。  
如果需要排除其他程式的視窗，建議尋找其他專業工具或等待未來的 DLL 注入完整實現。
